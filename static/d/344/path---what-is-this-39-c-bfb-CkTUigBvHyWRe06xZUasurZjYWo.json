{"data":{"site":{"siteMetadata":{"title":"鹊巢小筑","author":"Sean"}},"markdownRemark":{"id":"54be2420-2554-53f8-bdd4-4b24fd0398e6","excerpt":"如果你不清楚如何判断 JS 函数中 this 的值是什么，也许你可以花些时间阅读一下这一篇博客。 在解释 值判断问题前，需要简单提一下另外一个同样重要，同样让 JS 新手困惑的知识点( 闭包 )，因为对闭包的判断常常和对  值的判断弄混淆。 闭包的判断和 判断最大的不同就是， 闭包是在代码编写时就确定的，而 this…","html":"<p>如果你不清楚如何判断 JS 函数中 this 的值是什么，也许你可以花些时间阅读一下这一篇博客。</p>\n<p>在解释<code class=\"language-text\">this</code>值判断问题前，需要简单提一下另外一个同样重要，同样让 JS 新手困惑的知识点(<strong>闭包</strong>)，因为对闭包的判断常常和对 <code class=\"language-text\">this</code>值的判断弄混淆。</p>\n<p>闭包的判断和<code class=\"language-text\">this</code>判断最大的不同就是，<strong>闭包是在代码编写时就确定的，而 this 值的判定则是当函数调用的时候<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>才能确定，这一点非常重要</strong>, 举个例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> names <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'jim'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Bob'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'Amy'</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">const</span> funcs <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">funcGenerator</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">generatedFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"I'm \"</span> <span class=\"token operator\">+</span> name<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>name <span class=\"token keyword\">of</span> names<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  funcs<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token function\">funcGenerator</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>func <span class=\"token keyword\">of</span> funcs<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 输出结果</span>\n<span class=\"token comment\">// I'm jim</span>\n<span class=\"token comment\">// I'm Bob</span>\n<span class=\"token comment\">// I'm Amy</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>第 9 行的循环里，<code class=\"language-text\">funcGenerator</code>被调用了三次，分别传入<code class=\"language-text\">jim</code> <code class=\"language-text\">Bob</code> <code class=\"language-text\">Amy</code>。返回的新函数存入<code class=\"language-text\">funcs</code>数组内。注意到到循环结束，生成的函数并没有被调用，而是被保存到了函数定义所处作用域<em>(funcGenerator 内部)</em>的外面。当这三个函数在第 14 行被调用的时候，已经和<code class=\"language-text\">funcGenerator</code>内的<code class=\"language-text\">name</code>参数不在同一个作用域中，但是返回的每个函数内部的<code class=\"language-text\">name</code>引用，任然可以访问<code class=\"language-text\">name</code>参数的值，这就是闭包在发挥作用，目前，关于闭包你只需要记住上面黑体字的部分。</p>\n<hr>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'tom'</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> name <span class=\"token operator\">=</span> <span class=\"token string\">'jim'</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name\n<span class=\"token punctuation\">}</span>\n\nfoo<span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> <span class=\"token string\">'ellen'</span>\n\n<span class=\"token keyword\">let</span> bar <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Bob'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function\">whoAmI</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> baz <span class=\"token operator\">=</span> bar<span class=\"token punctuation\">.</span>whoAmI\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nbar<span class=\"token punctuation\">.</span><span class=\"token function\">whoAmI</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>在 JavaSript 中函数的<code class=\"language-text\">this</code>值的判断遵循四条规则，它们之间有优先级的区别，最先被满足条件的规则决定了 this 的值，我先从优先级最低的开始介绍。\n那么上面代码中第 19 行输出的结果是多少呢？如果你回答是<code class=\"language-text\">&#39;ellen&#39;</code>，恭喜你答错了。假设 this 其实指向 function 自身，是常见的误解之一，第 14 行对<code class=\"language-text\">foo</code>的<code class=\"language-text\">name</code>属性的赋值并不会影响到 this 的值。</p>\n<p>如果你说：“答案是 <code class=\"language-text\">jim</code>，<code class=\"language-text\">foo</code> 函数内就定义了 <code class=\"language-text\">name</code> 这个变量，然后最后返回这个值。“，恭喜你又错了，<code class=\"language-text\">this</code>的值也不是指向函数的作用域链<em>(尽管有时候，结果是一致的，后面会解释)</em></p>\n<p>正确的回答是<code class=\"language-text\">tom</code>，而答案揭晓的同时也介绍第一条规则，也是优先级最低的，只有当其它规则都无法满足的时候，这一条规则才会生效。</p>\n<h6>第一条规则</h6>\n<blockquote>\n<p>当一个函数被直接的调用时，this 的值指向 window 这个对象，当使用”use strick”模式时，this 的值是 undefined。</p>\n</blockquote>\n<p>这里说的直接调用，指的就是<code class=\"language-text\">foo()</code>这种形式，因为第一行代码在全局作用域定义了一个 name 的变量，也就是给 window.name 赋了一个新值。所以函数的返回值就是这个值。<em>（这里如果用 ES6 中的 let 关键字声明变量的话，结果会不一样，我推荐你试试这种方法，并找出导致结果不一样的原因）</em></p>\n<p>现在可以解释，为什么有时候用”this 指向函数作用域链”这种想法去解释结果，貌似也有道理。“如果第 4 行没有在<code class=\"language-text\">foo</code>内定义一个变量<code class=\"language-text\">name</code>，那么顺着作用域链去查找的话，就会在 window 这个全局作用域上找到<code class=\"language-text\">name</code>。” 但事实是，结果的一致只是凑巧而已，<strong><code class=\"language-text\">this</code>的值绝对不是函数的作用域链</strong>。</p>\n<h6>第二条规则，比第一条优先：</h6>\n<blockquote>\n<p>当一个函数以对象方法的形式被调用的时候，this 指向这个对象，可以使用 this.加上对象的属性名引用该对象的所有属性。\n也可以说是 this 值的隐性绑定(implicit bind)</p>\n</blockquote>\n<p>那么你可以想到，因为上面的规则，第 20 行代码输出的结果是<code class=\"language-text\">Bob</code>。<strong>对象的方法</strong>这种说法，来自于面向对象的编程思想。我更倾向不使用对象的方法这种说法，因为在 JavaScript 中，一个函数并不被一个对象所拥有，对象只是拥有一个函数的引用，一切都是对象的属性。由此引出一个陷阱。第 17 行代码，把所谓<strong>对象的方法</strong>保存到一个变量中，结果输出是<code class=\"language-text\">window</code>中的<code class=\"language-text\">name</code>，而不是<code class=\"language-text\">bar</code>中的<code class=\"language-text\">name</code>。正如前面所说的，对像只是拥有函数的引用，而不是函数本身。函数在何处定义同样不重要，无论是在对象内部被定义后被外部变量引用，还是将在别处被定义的函数的引用保存到对象的属性上，最终决定 this 的，还是函数的调用栈。<code class=\"language-text\">object.function()</code>只有这种形式的函数调用，this 才指向对象。</p>\n<p>上面的代码的最后三行的输出是</p>\n<ul>\n<li><code class=\"language-text\">tom</code></li>\n<li><code class=\"language-text\">Bob</code></li>\n<li><code class=\"language-text\">tom</code></li>\n</ul>\n<h6>第三条规则，比第二条优先：</h6>\n<blockquote>\n<p>从 ES5 开始每个函数上多了两个方法，<code class=\"language-text\">call</code>和<code class=\"language-text\">apply</code>，两个方法的作用相同。 用法上，将需要绑定到 this 值的对象做为第一个参数传入(explicit bind)。对于 call 方法，\b 第一个参数后可以接任意个数的值，这些值会被传入被调用的函数做为参数。而 apply 的第二个参数则是接受一个数组，这个数组会做为参数传入被调用的函数。</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> bar <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Jobs'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\nfoo<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span> <span class=\"token comment\">//输出Jobs</span>\nfoo<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span> <span class=\"token comment\">//输出Jobs</span>\n\n<span class=\"token keyword\">var</span> baz <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Jim'</span><span class=\"token punctuation\">,</span>\n  whoAmI<span class=\"token punctuation\">:</span> foo<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\nbaz<span class=\"token punctuation\">.</span>whoAMI<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>bar<span class=\"token punctuation\">)</span> <span class=\"token comment\">//输出jobs</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>第 9，10 两行函数调用都使用了显式的 this 绑定。即使没有使用<code class=\"language-text\">object.function()</code>这种形式调用，函数的 this 值依然指向<code class=\"language-text\">bar</code>对象。第 17 行函数同时使用了对象的方法和 call 方法，因为 call 的优先级比较高，所以 this 的值是对象 bar，输出结果是<code class=\"language-text\">jobs</code>。如果多次函数调用需要绑定同样对象，函数后面加上 call 或 apply 这种写法略显繁琐，你可以用一个嵌套函数去返回一个用 apply 或 call 绑定过的函数调用，例如：</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Jobs'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">fooBinded</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> foo<span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">fooBinded</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//输出 Jobs</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>你可以自己写一个工具方法，抽象出函数包装的逻辑，避免代码了的重复并改善代码的可读性。但是更好的选择是使用 bind 方法。bind 方法同样存在于每个函数对象上，它的作用和我们写的函数包装工具方法一样，但逻辑上更为谨慎，考虑到一些特殊情况下函数的表现。</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> obj <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Jobs'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> fooAfterBind <span class=\"token operator\">=</span> foo<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>obj<span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">fooAfterBind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">//输出 Jobs</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>终于介绍到最后一个规则，是优先级最高的一个。</p>\n<h6>第四条规则</h6>\n<blockquote>\n<p>函数调用时，前面加上 new 关键字，就是一次 new 调用。new 调用是 JavaScript 中用来模仿 OOP<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>中构造函数的调用的语法。new 调用时，会创建一个新的对象，函数内的 this 就指向这个新对象。</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-javascript line-numbers\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>name <span class=\"token operator\">=</span> name\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Jobs'</span><span class=\"token punctuation\">)</span>\n\nperson<span class=\"token punctuation\">.</span>name <span class=\"token comment\">//输出 Jobs</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>即使使用强绑定<code class=\"language-text\">var BindedPerson = Person.bind({name: &#39;sean&#39;})</code>，这时调用<code class=\"language-text\">new BindedPerson(&#39;Jobs&#39;)</code>返回的对象的 name 属性的值依然是 Jobs。这就是之前提到过 bind 处理的特殊情况。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>函数的调用栈(function call stack)。</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p>OOP(Object Oriented Programming) 面向对象编程。</p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"JavaScript函数中的this指的到底是什么？","date":" 2019年 一月 30"}}},"pageContext":{"slug":"/what-is-this/","previous":{"fields":{"slug":"/hello-world/"},"frontmatter":{"title":"简单的自我介绍"}},"next":null}}