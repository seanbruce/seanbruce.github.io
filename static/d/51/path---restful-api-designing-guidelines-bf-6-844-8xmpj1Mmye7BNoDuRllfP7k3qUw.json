{"data":{"site":{"siteMetadata":{"title":"鹊巢小筑","author":"Sean"}},"markdownRemark":{"id":"f372df27-635e-5882-80f0-f61fbafdbe5b","excerpt":"这是一篇 medium 上关于 RESTFull API 文章。我觉得对于刚接触 RESTFull API 的后端程序员来说这是非常好的入门文章，就把这篇文章翻译成中文后放在我的博客上，为英语不是很好，或者不能访问 medium 的同学提供方便。 原文地址点这里 。 RESTFull API…","html":"<p>这是一篇 medium 上关于 RESTFull API 文章。我觉得对于刚接触 RESTFull API 的后端程序员来说这是非常好的入门文章，就把这篇文章翻译成中文后放在我的博客上，为英语不是很好，或者不能访问 medium 的同学提供方便。<a href=\"https://hackernoon.com/restful-api-designing-guidelines-the-best-practices-60e1d954e7c9\">原文地址点这里</a>。</p>\n<h3>RESTFull API 的设计指南及最佳实践</h3>\n<p>脸书、谷歌、Github 和网飞以及其它几个科技巨头公司，允许外部的开发者或互联网应用，通过访问 API(应用开发接口) 的方式使用它们的数据，形成了以 API 为基础数据平台。\n<br />\n做为开发 API 的后端，即使 API 是在公司内部使用不开放给外部的开发者，也应该注意接口设计的好坏，一个设计良好的 API 对你的应用总是有好处的。</p>\n<p>互联网上关于什么是 API 设计的最佳实践的辩论日久不休，对这个话题的争论牵扯到许多细节问题，而且没有一个正式、官方的指南。</p>\n<p>API\b 提供一个接口，开发者们通过对接口访问操作数据。设计良好的 API 使用起来非常方便，让开发者的工作轻松许多。对于开发者来说 API 就像图形界面一样（GUI），如果开发人员感觉到这个界面不是非常清晰直观，那么就会开始搜寻替代品，或者干脆就不用了。</p>\n<blockquote>\n<p>API 就像是街头艺人，而它的用户就是观众。</p>\n</blockquote>\n<h4>1) 术语解释</h4>\n<p>以下是和 REST API 密切相关的术语</p>\n<ul>\n<li>\n<p>Resource 是某些数据资源的表示，含有与之相关的数据和用来操作数据的方法。比如：动物、学校和员工是资源，删除、添加、更新是对这些资源执行的操作(action)。</p>\n</li>\n<li>\n<p>Collections 是一系列资源的集合。比如：Companies 是 Company 资源的集合。</p>\n</li>\n<li>\n<p>URL(统一资源定位符)是资源访问的路径，而且在这个路径上可以执行一些操作。</p>\n</li>\n</ul>\n<h4>2) API endpoint(接口端点)</h4>\n<p>为了更好的理解上面的概念，我们写几个接口，比如<strong>公司</strong>里面有<strong>员工</strong></p>\n<ul>\n<li><code class=\"language-text\">/getAllEmployees 返回员工的数组</code></li>\n<li><code class=\"language-text\">/addNewEmployee 新增一个员工</code></li>\n<li><code class=\"language-text\">/deleteEmployee 删除一个员工</code></li>\n<li><code class=\"language-text\">/deleteAllEmployee 删除所有员工</code></li>\n<li><code class=\"language-text\">/promoteEmployee 让一个员工升职</code></li>\n<li><code class=\"language-text\">/promoteAllEmployee 让所有员工升职</code></li>\n</ul>\n<p>关于员工还有许多接口，每个接口执行一种操作, 当然这其中包含许多冗余的操作。当 API 的数量增加时，这种接口设计会成为维护上的负担。</p>\n<p><strong>哪里做错了？</strong>\n<br />\nURL 地址里应该只包含 resource，而不包括 action。<code class=\"language-text\">/addNewEmployee</code>这个 API 地址里面不仅包含了 resource<code class=\"language-text\">Employee</code>还包含了执行的 action<code class=\"language-text\">addNew</code></p>\n<p><strong>正确的做法是？</strong>\n<br />\n<code class=\"language-text\">/companies</code>像这样一个 API 地址就是一个好的例子，因为它不包含操作。但现在的问题是我们如何告知服务器，需要在 resource 上要进行什么操作，是增加、删除、还是修改呢？</p>\n<p>区分不同的操作要依靠不同的 HTTP 请求方法(GET, POST, DELETE, PUT)。</p>\n<p>所有接口端点中表示资源的单词应该始终是复数形式，比如<code class=\"language-text\">companies</code>和<code class=\"language-text\">schools</code>。如果需要返回数据集中单独的一条时，我们可以在地址后面拼上 id</p>\n<ul>\n<li>HTTP 请求方法 <code class=\"language-text\">GET</code> 路径 <code class=\"language-text\">/companies</code> 应当返回含有所有公司信息的数组</li>\n<li>HTTP 请求方法 <code class=\"language-text\">GET</code> 路径 <code class=\"language-text\">/companies/34</code> 应当返回 id 为 34 的公司的信息</li>\n<li>HTTP 请求方法 <code class=\"language-text\">DELETE</code> 路径 <code class=\"language-text\">/companies/34</code> 应当删除 id 为 34 的公司的信息</li>\n</ul>\n<p>在一些少数情况下，如果资源之间有层级关系，比如不同的公司里面有不同的员工，那么接口端点会像这样:</p>\n<ul>\n<li><code class=\"language-text\">GET /companies/3/employees</code> 应该返回 id 为 3 的公司所有的员工信息</li>\n<li><code class=\"language-text\">GET /companies/3/employees/45</code> 应该返回 id 为 3 的公司中 id 为 45 的员工的信息</li>\n<li><code class=\"language-text\">DELETE /companies/3/employees/45</code> 应该删除 id 为 3 的公司中 id 为 45 的员工的信息</li>\n<li><code class=\"language-text\">POST /companies</code> 应该新建一个公司，并且返回这个新增公司的详细信息。</li>\n</ul>\n<p>这样子设计的 API 是不是简洁性和一致性更好？</p>\n<p><strong><em>结论:</em></strong>\bAPI 路径中的资源要使用复数的英语单词，并且使用不同的 HTTP 请求方法定义不同的资源操作。</p>\n<h4>3) HTTP 请求方法</h4>\n<p>HTTP 定义了一组请求方法，这些方法指明了需要在资源上执行的操作的类型。</p>\n<blockquote>\n<p>URL 就像一个句子，资源是名词，HTTP 请求方法是动词。</p>\n</blockquote>\n<p>最要的 HTTP 方法如下:</p>\n<ol>\n<li><code class=\"language-text\">GET</code> 方法请求返回数据，使用 GET 方法不应该产生副作用(side effect)。</li>\n<li><code class=\"language-text\">POST</code> 方法请求服务端在数据库中创建数据，HTML 中提交表格用的就是<code class=\"language-text\">POST</code>方法。<br />\n比如 API: <code class=\"language-text\">/companies/3/employees</code>的意思是在 id 为 3 的公司中创建新员工。<br />\n<code class=\"language-text\">POST</code>方法是<em>non-idempotent</em>(非幂等?不知道怎么翻译)，意味着多次请求的效果是不同的。</li>\n<li><code class=\"language-text\">PUT</code> 方法请求服务端更新一条数据，或创建一条数据(<em>如果数据不存在的话</em>)。<br />\n比如 API: <code class=\"language-text\">/companies/3/employees/john</code> 会要求服务器更新 id 为 3 的公司里这个叫 john 员工的信息。<br /><code class=\"language-text\">PUT</code> 方法是<em>idempotent</em>(幂等？同样不确认怎么翻译)，意味着多次请求的效果是一样的。</li>\n<li><code class=\"language-text\">DELETE</code> 方法请求服务端，某个资源，或某个资源中其中一条数据从数据库中删除。<br />\n比如 API: `/companies/3/employees/john 请求服务器从 id 为 3 的公司员工信息中删除 john 的信息。</li>\n</ol>\n<p>其它的<a href=\"https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods\">HTTP 请求方法</a>将会在其它的博客中介绍。</p>\n<h4>4) HTTP 返回状态码</h4>\n<p>客户端发起请求，通过 API 访问服务端后，服务端应该给予操作的回馈，这次操作是失败了，还是成功了，请求中的参数是不是有什么错误。HTTP 返回码是一系列标准化的代码，在不同的场景下有不同的解释。服务端应该始终返回正确的状态码。<br />\nHTTP 返回码可以根据类型分组，下面是一些重要的类型:</p>\n<h5>2xx(成功类型)</h5>\n<p>这个类型下的返回码表示服务端成功接收到操作的请求，并且成功的执行。</p>\n<ul>\n<li>\n<p>200 ok 这个返回码表示<code class=\"language-text\">GET</code>,<code class=\"language-text\">PUT</code>或<code class=\"language-text\">POST</code>请求成功执行。</p>\n</li>\n<li>\n<p>201 created 这个返回码表示数据的成功创建。比如，使用<code class=\"language-text\">PUT</code>方法请求创建新的新的数据成功后，应该返回 201。</p>\n</li>\n<li>\n<p>204 no countent 表示成功的处理了请求，但是没有任何返回数据。<br />\n一个比较好的例子就是:`DELETE /companies/43/employees/2 会删除这个员工的信息，但在返回的 body 中，我们并不需要任何数据，因为我们明确的告诉服务器我们要删除这条记录。如果操作有任何的错误，比如数据库中没有这个员工的数据的话，返回值就不会是 2xx 成功类型，而是 4xx 客户端错误类型。</p>\n</li>\n</ul>\n<h5>3xx(重定向类型)</h5>\n<ul>\n<li>304 Not Modified 表示客户端本地已经有这次请求数据的缓存，服务端不需要再次传输同样的数据。</li>\n</ul>\n<h5>4xx(客户端错误类型)</h5>\n<p>这个类型的返回码表示客户端发起的起求有错误</p>\n<ul>\n<li>\n<p>400 Bad Request 表示服务端不清楚这次请求，所以没有处理。</p>\n</li>\n<li>\n<p>401 Unauthorized 表示客户端没有被授权访问这个 resource，应该带上授权凭证再次尝试请求。</p>\n</li>\n<li>\n<p>403 Forbidden 表示请求是正确的，但是用户无权访问这些 resource。</p>\n</li>\n<li>\n<p>404 Not Found 表示请求的 resouces，目前不可用。</p>\n</li>\n<li>\n<p>410 Gone 表示请求的 resources 不再可用了，因为被有意的从服务端移除。</p>\n</li>\n</ul>\n<h5>5xx(服务端错误类型)</h5>\n<ul>\n<li>\n<p>500 Internal Server Error 表示请求是正确的，但是在服务端处理时发生了错误。</p>\n</li>\n<li>\n<p>503 Server Unavailable 表示服务端不在线或无法接收处理请求。通常因为服务器在维护。</p>\n</li>\n</ul>\n<h4>5) 字段命名规则</h4>\n<p>你可以使用任何命名规则，但要注意整个应用内命名的一致性。如果请求的 body 或返回的 body 中使用的是 JSON 类型的数据，那么请使用<code class=\"language-text\">camelCase(驼锋风格)</code>\b。</p>\n<h4>6) 搜索、排序、过滤和分页</h4>\n<p>这些都是对某数据集的查询，不会特意去创建新的 API 去进行这些查询。我们需要在使用<code class=\"language-text\">GET</code>请求方法的 API 的 URL 中拼接上查询的参数。<br />\n让我们看一些例子是如何实现这些操作的。</p>\n<ul>\n<li>\n<p>对返回的结果<strong>排序</strong>，如果需要对返回的公司信息进行排序，<code class=\"language-text\">GET /companies</code>这个端点应该能接收多个查询参数。比如: <code class=\"language-text\">GET /companies?sort=rank_asc</code>这个请求将返回的公司信息按排名的升序排列。</p>\n</li>\n<li>\n<p>对返回的结果<strong>过滤</strong>，我可以在查询参数中传递不同的过滤选项。<br />\n比如这个请求: <code class=\"language-text\">GET /companies?category=banking&amp;location=india</code> 会过滤出所有在印度的银行业的公司。</p>\n</li>\n<li>\n<p>\b<strong>搜索</strong>，按名称搜索一个公司信息，这个 API 端点应该类似于 <code class=\"language-text\">\b\b\b\b\bGET /companies?search=Digital Mackinsey</code>。</p>\n</li>\n<li>\n<p>数据集过于庞大的时候需要<strong>分页</strong>，把数据分成小块后返回，可以提升性能并且更容易去处理返回值。比如: <code class=\"language-text\">GET /companies?page=23</code>会返回所有公司信息的第 23 页。</p>\n</li>\n</ul>\n<p>如果 URL 中拼接了太多的查询参数，可能导致 URL 超过长度限制，服服端可能返回<code class=\"language-text\">414 URI too long</code>的错误状态代码。解决这个问题就不能用<code class=\"language-text\">GET</code>方法请求，需要使用<code class=\"language-text\">POST</code>，然后在请求 body 中传递参数。</p>\n<h4>7) 版本管理</h4>\n<p>如果你的 API 对外开放，升级其中的接口造成重大改变可能导致使用了你的 API 的服务或产品出现错误。\n<br/>\n<code class=\"language-text\">http://api.yourservice.com/v1/companies/34/employees</code> 就是一个设计良好的例子，在 API 的路径中包含了版本号。如果有重大改动的主要版本更新，我们可以在 API 中声明不同的版本号使用不同版本的 API，比如<code class=\"language-text\">v2</code>或<code class=\"language-text\">v1.x.x</code>。</p>\n<p><strong><em>结束</em></strong></p>","frontmatter":{"title":"RESTFull API 的设计指南和最佳实践","date":" 2019年 二月 12","tags":["RESTFull API 最佳实践"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/restful-api-designing-guidelines/","previous":{"fields":{"slug":"/what-is-this/"},"frontmatter":{"title":"JavaScript函数中的this指的到底是什么？"}},"next":{"fields":{"slug":"/coerce/"},"frontmatter":{"title":"JavaScript中的类型转换"}}}}