<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[鹊巢小筑]]></title><description><![CDATA[一个分享前端技术的博客]]></description><link>https://seanbruce.github.io</link><generator>RSS for Node</generator><lastBuildDate>Tue, 12 Feb 2019 00:49:51 GMT</lastBuildDate><item><title><![CDATA[JavaScript函数中的this指的到底是什么？]]></title><description><![CDATA[如果你不清楚如何判断 JS 函数中 this 的值是什么，也许你可以花些时间阅读一下这一篇博客。 在解释 值判断问题前，需要简单提一下另外一个同样重要，同样让 JS…]]></description><link>https://seanbruce.github.io/what-is-this/</link><guid isPermaLink="false">https://seanbruce.github.io/what-is-this/</guid><pubDate>Wed, 30 Jan 2019 08:51:19 GMT</pubDate><content:encoded>&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/1bdf0dabe232dbd3430c3dae441680c9/a8a50/background.jpeg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 66.640625%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHnVKphg//EABoQAQABBQAAAAAAAAAAAAAAAAIBABARIjH/2gAIAQEAAQUCHZVhOEtpr//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABgQAAIDAAAAAAAAAAAAAAAAAAAQAREh/9oACAEBAAY/AjYdr//EABsQAQACAgMAAAAAAAAAAAAAAAEAEBExIVGR/9oACAEBAAE/IQ6TBwondeREq91//9oADAMBAAIAAwAAABDw/wD/xAAVEQEBAAAAAAAAAAAAAAAAAAAQIf/aAAgBAwEBPxCn/8QAFREBAQAAAAAAAAAAAAAAAAAAECH/2gAIAQIBAT8Qh//EABsQAAIDAAMAAAAAAAAAAAAAAAERACExEIGh/9oACAEBAAE/ECCRlLYYqwUj7qEsteQjk2Q2EFtZ4//Z&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;programming&quot;
        title=&quot;&quot;
        src=&quot;/static/1bdf0dabe232dbd3430c3dae441680c9/f8fb9/background.jpeg&quot;
        srcset=&quot;/static/1bdf0dabe232dbd3430c3dae441680c9/e8976/background.jpeg 148w,
/static/1bdf0dabe232dbd3430c3dae441680c9/63df2/background.jpeg 295w,
/static/1bdf0dabe232dbd3430c3dae441680c9/f8fb9/background.jpeg 590w,
/static/1bdf0dabe232dbd3430c3dae441680c9/85e3d/background.jpeg 885w,
/static/1bdf0dabe232dbd3430c3dae441680c9/d1924/background.jpeg 1180w,
/static/1bdf0dabe232dbd3430c3dae441680c9/a8a50/background.jpeg 1280w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;如果你不清楚如何判断 JS 函数中 this 的值是什么，也许你可以花些时间阅读一下这一篇博客。&lt;/p&gt;
&lt;p&gt;在解释&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;值判断问题前，需要简单提一下另外一个同样重要，同样让 JS 新手困惑的知识点(&lt;strong&gt;闭包&lt;/strong&gt;)，因为对闭包的判断常常和对 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;值的判断弄混淆。&lt;/p&gt;
&lt;p&gt;闭包的判断和&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;判断最大的不同就是，&lt;strong&gt;闭包是在代码编写时就确定的，而 this 值的判定则是当函数调用的时候&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;才能确定，这一点非常重要&lt;/strong&gt;, 举个例子：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber NaN&quot; class=&quot;language-javascript line-numbers&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; names &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;jim&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Bob&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Amy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; funcs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;funcGenerator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;generatedFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;I&apos;m &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; names&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  funcs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;funcGenerator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;func &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; funcs&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 输出结果&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// I&apos;m jim&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// I&apos;m Bob&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// I&apos;m Amy&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第 9 行的循环里，&lt;code class=&quot;language-text&quot;&gt;funcGenerator&lt;/code&gt;被调用了三次，分别传入&lt;code class=&quot;language-text&quot;&gt;jim&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Bob&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Amy&lt;/code&gt;。返回的新函数存入&lt;code class=&quot;language-text&quot;&gt;funcs&lt;/code&gt;数组内。注意到到循环结束，生成的函数并没有被调用，而是被保存到了函数定义所处作用域&lt;em&gt;(funcGenerator 内部)&lt;/em&gt;的外面。当这三个函数在第 14 行被调用的时候，已经和&lt;code class=&quot;language-text&quot;&gt;funcGenerator&lt;/code&gt;内的&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;参数不在同一个作用域中，但是返回的每个函数内部的&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;引用，任然可以访问&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;参数的值，这就是闭包在发挥作用，目前，关于闭包你只需要记住上面黑体字的部分。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber NaN&quot; class=&quot;language-javascript line-numbers&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;tom&apos;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;jim&apos;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;ellen&apos;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; bar &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Bob&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;whoAmI&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; baz &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; bar&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;whoAmI

&lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
bar&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;whoAmI&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;baz&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 JavaSript 中函数的&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;值的判断遵循四条规则，它们之间有优先级的区别，最先被符合条件的规则决定了 this 的值，我按照优先级由低到高的顺序来介绍。&lt;/p&gt;
&lt;p&gt;上面代码中第 19 行输出的结果是多少？如果你回答是&lt;code class=&quot;language-text&quot;&gt;&amp;#39;ellen&amp;#39;&lt;/code&gt;，恭喜你答错了。假设 this 其实指向 function 自身，是常见的误解之一，第 14 行对&lt;code class=&quot;language-text&quot;&gt;foo&lt;/code&gt;的&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;属性的赋值并不会影响到 this 的值。&lt;/p&gt;
&lt;p&gt;如果你说：“答案是 &lt;code class=&quot;language-text&quot;&gt;jim&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;foo&lt;/code&gt; 函数内就定义了 &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt; 这个变量，然后最后返回这个值。“，恭喜你又错了，&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;的值也不是指向函数的作用域链&lt;em&gt;(尽管有时候，结果看似是一致的，后面会解释)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;正确的回答是&lt;code class=&quot;language-text&quot;&gt;tom&lt;/code&gt;，为什么？&lt;/p&gt;
&lt;h6&gt;第一条规则&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;当一个函数被直接的调用时，this 的值指向 window 这个对象，当使用”use strick”模式时，this 的值是 undefined。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里说的直接调用，指的就是&lt;code class=&quot;language-text&quot;&gt;foo()&lt;/code&gt;这种形式，第一行代码在全局作用域&lt;em&gt;window&lt;/em&gt;下定义了一个 name 的变量，即&lt;code class=&quot;language-text&quot;&gt;window.name = &amp;#39;tom&amp;#39;&lt;/code&gt;。this 指向的是&lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt;。&lt;em&gt;（这里如果用 ES6 中的 let 关键字声明变量的话，结果会不一样，我推荐你试试这种方法，并找出导致结果不一样的原因）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;现在可以解释，为什么输出的结果看起来像是对原型链的访问。有一种假设：如果第 4 行没有在&lt;code class=&quot;language-text&quot;&gt;foo&lt;/code&gt;内定义一个变量&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;，那么顺着作用域链去查找的话，就会在 window 这个全局作用域上找到&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;。 但事实是假设是错误的，结果的一致只是凑巧而已，&lt;strong&gt;&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;的值绝对不是函数的作用域链&lt;/strong&gt;。&lt;/p&gt;
&lt;h6&gt;第二条规则，比第一条优先：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;当一个函数以对象方法的形式被调用的时候，this 指向这个对象，可以使用 this.加上对象的属性名引用该对象的所有属性。
也可以说是 this 值的隐性绑定(implicit bind)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么你可以想到，因为上面的规则，第 20 行代码输出的结果是&lt;code class=&quot;language-text&quot;&gt;Bob&lt;/code&gt;。&lt;strong&gt;对象的方法&lt;/strong&gt;这种说法，来自于面向对象的编程思想。我更倾向不使用”对象的方法”这种说法，因为在 JavaScript 中，一个函数并不被一个对象所拥有，对象只是拥有一个函数的引用，一切都是对象的属性。由此引出一个陷阱。第 17 行代码，把&lt;strong&gt;对象的方法&lt;/strong&gt;保存到对象外一个变量中，结果输出是&lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt;中的&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;，而不是&lt;code class=&quot;language-text&quot;&gt;bar&lt;/code&gt;中的&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;。正如前面所说的，对像只是拥有函数的引用，而不是函数本身。函数在何处定义同样不重要，无论是在对象内部被定义后被外部变量引用，还是将在别处被定义的函数的引用保存到对象的属性上，最终决定 this 的，还是函数的调用栈。&lt;code class=&quot;language-text&quot;&gt;object.function()&lt;/code&gt;只有这种形式的函数调用，this 才指向对象。&lt;/p&gt;
&lt;p&gt;上面的代码的最后三行的输出是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;tom&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Bob&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;tom&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h6&gt;第三条规则，比第二条优先：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;从 ES5 开始每个函数的原型上多了两个方法，&lt;code class=&quot;language-text&quot;&gt;call&lt;/code&gt;和&lt;code class=&quot;language-text&quot;&gt;apply&lt;/code&gt;，两个方法的作用相同。 用法上，将需要绑定到 this 值的对象做为第一个参数传入(explicit bind)。对于 call 方法， 第一个参数后可以接任意个数的值，这些值会被传入被调用的函数做为参数。而 apply 的第二个参数则是接受一个数组，这个数组会做为参数传入被调用的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber NaN&quot; class=&quot;language-javascript line-numbers&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; bar &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Jobs&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bar&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//输出Jobs&lt;/span&gt;
foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bar&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//输出Jobs&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; baz &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Jim&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  whoAmI&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; foo&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

baz&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;whoAMI&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bar&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//输出jobs&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第 9，10 两行函数调用都使用了显式的 this 绑定。即使没有使用&lt;code class=&quot;language-text&quot;&gt;object.function()&lt;/code&gt;这种形式调用，函数的 this 值依然指向&lt;code class=&quot;language-text&quot;&gt;bar&lt;/code&gt;对象。第 17 行函数同时使用了对象的方法和 call 方法，因为 call 的优先级比较高，所以 this 的值是对象 bar，输出结果是&lt;code class=&quot;language-text&quot;&gt;jobs&lt;/code&gt;。如果多次函数调用需要绑定同样对象，函数后面加上 call 或 apply 这种写法略显繁琐，你可以用一个嵌套函数去返回一个用 apply 或 call 绑定过的函数调用，例如：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber NaN&quot; class=&quot;language-javascript line-numbers&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Jobs&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fooBinded&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;obj&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;fooBinded&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//输出 Jobs&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以自己写一个工具方法，抽象出函数包装的逻辑，避免代码了的重复并改善代码的可读性。但是更好的选择是使用函数原型上的 bind 方法。它的作用和函数包装 util 方法一样，但逻辑上更为谨慎，考虑到一些特殊情况下函数的表现。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber NaN&quot; class=&quot;language-javascript line-numbers&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Jobs&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; fooAfterBind &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;obj&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;fooAfterBind&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//输出 Jobs&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;终于介绍到最后一个规则，是优先级最高的一个。&lt;/p&gt;
&lt;h6&gt;第四条规则&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;函数调用时，前面加上 new 关键字，就是一次 new 调用。new 调用是 JavaScript 中用来模仿 OOP&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;中构造函数的调用的语法。new 调用时，会创建一个新的对象，函数内的 this 就指向这个新对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber NaN&quot; class=&quot;language-javascript line-numbers&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; person &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Jobs&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

person&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token comment&quot;&gt;//输出 Jobs&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即使使用强绑定&lt;code class=&quot;language-text&quot;&gt;var BindedPerson = Person.bind({name: &amp;#39;sean&amp;#39;})&lt;/code&gt;，这时调用&lt;code class=&quot;language-text&quot;&gt;new BindedPerson(&amp;#39;Jobs&amp;#39;)&lt;/code&gt;返回的对象的 name 属性的值依然是 Jobs。这就是之前提到过 bind 处理的特殊情况。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;总结关于 this 值的知识点，判定函数内 this 值依赖四个规则，从优先级高到低分别是：new 函数调用、强绑定&lt;code class=&quot;language-text&quot;&gt;bind&lt;/code&gt;弱绑定&lt;code class=&quot;language-text&quot;&gt;apply``call&lt;/code&gt;、方法调用、普通函数调用。第一个符合条件的规则决定了 this 的值。理解 this 对理解 JavaScript 中的面向对象编程是必要的。可能在以后我会写一篇 Javascript 中的面向对象基础的博客。&lt;/p&gt;
&lt;p&gt;这篇博客就结束啦，see you next time!&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;函数的调用栈(function call stack)。&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;OOP(Object Oriented Programming) 面向对象编程。&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[简单的自我介绍]]></title><description><![CDATA[我是一个热爱 WEB 前端技术，同时也热爱分享的人。 以后我会不定时的在这里分享一切技术博客，主要针对的是 WEB 前端的知识，包括 WEB 前端开发中使用的基本技术，常用工具，以及一些个人的心得。可能以后还会加入 Node.js…]]></description><link>https://seanbruce.github.io/hello-world/</link><guid isPermaLink="false">https://seanbruce.github.io/hello-world/</guid><pubDate>Mon, 28 Jan 2019 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;我是一个热爱 WEB 前端技术，同时也热爱分享的人。&lt;/p&gt;
&lt;p&gt;以后我会不定时的在这里分享一切技术博客，主要针对的是 WEB 前端的知识，包括 WEB 前端开发中使用的基本技术，常用工具，以及一些个人的心得。可能以后还会加入 Node.js 的一切文章。&lt;/p&gt;
&lt;p&gt;希望我的博客内容能包含大家感兴趣的话题。&lt;/p&gt;</content:encoded></item></channel></rss>