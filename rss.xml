<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[鹊巢小筑]]></title><description><![CDATA[一个分享前端技术的博客]]></description><link>https://seanbruce.github.io</link><generator>RSS for Node</generator><lastBuildDate>Wed, 13 Feb 2019 03:21:49 GMT</lastBuildDate><item><title><![CDATA[RESTFull API 的设计指南和最佳实践]]></title><description><![CDATA[这是一篇 medium 上关于 RESTFull API 文章。我觉得对于刚接触 RESTFull API 的后端程序员来说这是非常好的入门文章，就把这篇文章翻译成中文后放在我的博客上，为英语不是很好，或者不能访问 medium…]]></description><link>https://seanbruce.github.io/restful-api-designing-guidelines/</link><guid isPermaLink="false">https://seanbruce.github.io/restful-api-designing-guidelines/</guid><pubDate>Tue, 12 Feb 2019 08:42:49 GMT</pubDate><content:encoded>&lt;p&gt;这是一篇 medium 上关于 RESTFull API 文章。我觉得对于刚接触 RESTFull API 的后端程序员来说这是非常好的入门文章，就把这篇文章翻译成中文后放在我的博客上，为英语不是很好，或者不能访问 medium 的同学提供方便。&lt;a href=&quot;https://hackernoon.com/restful-api-designing-guidelines-the-best-practices-60e1d954e7c9&quot;&gt;原文地址点这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;RESTFull API 的设计指南及最佳实践&lt;/h3&gt;
&lt;p&gt;脸书、谷歌、Github 和网飞以及其它几个科技巨头公司，允许外部的开发者或互联网应用，通过访问 API(应用开发接口) 的方式使用它们的数据，形成了以 API 为基础数据平台。
&lt;br /&gt;
做为开发 API 的后端，即使 API 是在公司内部使用不开放给外部的开发者，也应该注意接口设计的好坏，一个设计良好的 API 对你的应用总是有好处的。&lt;/p&gt;
&lt;p&gt;互联网上关于什么是 API 设计的最佳实践的辩论日久不休，对这个话题的争论牵扯到许多细节问题，而且没有一个正式、官方的指南。&lt;/p&gt;
&lt;p&gt;API 提供一个接口，开发者们通过对接口访问操作数据。设计良好的 API 使用起来非常方便，让开发者的工作轻松许多。对于开发者来说 API 就像图形界面一样（GUI），如果开发人员感觉到这个界面不是非常清晰直观，那么就会开始搜寻替代品，或者干脆就不用了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;API 就像是街头艺人，而它的用户就是观众。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;1) 术语解释&lt;/h4&gt;
&lt;p&gt;以下是和 REST API 密切相关的术语&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Resource 是某些数据资源的表示，含有与之相关的数据和用来操作数据的方法。比如：动物、学校和员工是资源，删除、添加、更新是对这些资源执行的操作(action)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Collections 是一系列资源的集合。比如：Companies 是 Company 资源的集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;URL(统一资源定位符)是资源访问的路径，而且在这个路径上可以执行一些操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2) API endpoint(接口端点)&lt;/h4&gt;
&lt;p&gt;为了更好的理解上面的概念，我们写几个接口，比如&lt;strong&gt;公司&lt;/strong&gt;里面有&lt;strong&gt;员工&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;/getAllEmployees 返回员工的数组&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;/addNewEmployee 新增一个员工&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;/deleteEmployee 删除一个员工&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;/deleteAllEmployee 删除所有员工&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;/promoteEmployee 让一个员工升职&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;/promoteAllEmployee 让所有员工升职&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于员工还有许多接口，每个接口执行一种操作, 当然这其中包含许多冗余的操作。当 API 的数量增加时，这种接口设计会成为维护上的负担。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哪里做错了？&lt;/strong&gt;
&lt;br /&gt;
URL 地址里应该只包含 resource，而不包括 action。&lt;code class=&quot;language-text&quot;&gt;/addNewEmployee&lt;/code&gt;这个 API 地址里面不仅包含了 resource&lt;code class=&quot;language-text&quot;&gt;Employee&lt;/code&gt;还包含了执行的 action&lt;code class=&quot;language-text&quot;&gt;addNew&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正确的做法是？&lt;/strong&gt;
&lt;br /&gt;
&lt;code class=&quot;language-text&quot;&gt;/companies&lt;/code&gt;像这样一个 API 地址就是一个好的例子，因为它不包含操作。但现在的问题是我们如何告知服务器，需要在 resource 上要进行什么操作，是增加、删除、还是修改呢？&lt;/p&gt;
&lt;p&gt;区分不同的操作要依靠不同的 HTTP 请求方法(GET, POST, DELETE, PUT)。&lt;/p&gt;
&lt;p&gt;所有接口端点中表示资源的单词应该始终是复数形式，比如&lt;code class=&quot;language-text&quot;&gt;companies&lt;/code&gt;和&lt;code class=&quot;language-text&quot;&gt;schools&lt;/code&gt;。如果需要返回数据集中单独的一条时，我们可以在地址后面拼上 id&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP 请求方法 &lt;code class=&quot;language-text&quot;&gt;GET&lt;/code&gt; 路径 &lt;code class=&quot;language-text&quot;&gt;/companies&lt;/code&gt; 应当返回含有所有公司信息的数组&lt;/li&gt;
&lt;li&gt;HTTP 请求方法 &lt;code class=&quot;language-text&quot;&gt;GET&lt;/code&gt; 路径 &lt;code class=&quot;language-text&quot;&gt;/companies/34&lt;/code&gt; 应当返回 id 为 34 的公司的信息&lt;/li&gt;
&lt;li&gt;HTTP 请求方法 &lt;code class=&quot;language-text&quot;&gt;DELETE&lt;/code&gt; 路径 &lt;code class=&quot;language-text&quot;&gt;/companies/34&lt;/code&gt; 应当删除 id 为 34 的公司的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一些少数情况下，如果资源之间有层级关系，比如不同的公司里面有不同的员工，那么接口端点会像这样:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;GET /companies/3/employees&lt;/code&gt; 应该返回 id 为 3 的公司所有的员工信息&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;GET /companies/3/employees/45&lt;/code&gt; 应该返回 id 为 3 的公司中 id 为 45 的员工的信息&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;DELETE /companies/3/employees/45&lt;/code&gt; 应该删除 id 为 3 的公司中 id 为 45 的员工的信息&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;POST /companies&lt;/code&gt; 应该新建一个公司，并且返回这个新增公司的详细信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样子设计的 API 是不是简洁性和一致性更好？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;结论:&lt;/em&gt;&lt;/strong&gt;API 路径中的资源要使用复数的英语单词，并且使用不同的 HTTP 请求方法定义不同的资源操作。&lt;/p&gt;
&lt;h4&gt;3) HTTP 请求方法&lt;/h4&gt;
&lt;p&gt;HTTP 定义了一组请求方法，这些方法指明了需要在资源上执行的操作的类型。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;URL 就像一个句子，资源是名词，HTTP 请求方法是动词。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最要的 HTTP 方法如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;GET&lt;/code&gt; 方法请求返回数据，使用 GET 方法不应该产生副作用(side effect)。&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;POST&lt;/code&gt; 方法请求服务端在数据库中创建数据，HTML 中提交表格用的就是&lt;code class=&quot;language-text&quot;&gt;POST&lt;/code&gt;方法。&lt;br /&gt;
比如 API: &lt;code class=&quot;language-text&quot;&gt;/companies/3/employees&lt;/code&gt;的意思是在 id 为 3 的公司中创建新员工。&lt;br /&gt;
&lt;code class=&quot;language-text&quot;&gt;POST&lt;/code&gt;方法是&lt;em&gt;non-idempotent&lt;/em&gt;(非幂等?不知道怎么翻译)，意味着多次请求的效果是不同的。&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;PUT&lt;/code&gt; 方法请求服务端更新一条数据，或创建一条数据(&lt;em&gt;如果数据不存在的话&lt;/em&gt;)。&lt;br /&gt;
比如 API: &lt;code class=&quot;language-text&quot;&gt;/companies/3/employees/john&lt;/code&gt; 会要求服务器更新 id 为 3 的公司里这个叫 john 员工的信息。&lt;br /&gt;&lt;code class=&quot;language-text&quot;&gt;PUT&lt;/code&gt; 方法是&lt;em&gt;idempotent&lt;/em&gt;(幂等？同样不确认怎么翻译)，意味着多次请求的效果是一样的。&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;DELETE&lt;/code&gt; 方法请求服务端，某个资源，或某个资源中其中一条数据从数据库中删除。&lt;br /&gt;
比如 API: `/companies/3/employees/john 请求服务器从 id 为 3 的公司员工信息中删除 john 的信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其它的&lt;a href=&quot;https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods&quot;&gt;HTTP 请求方法&lt;/a&gt;将会在其它的博客中介绍。&lt;/p&gt;
&lt;h4&gt;4) HTTP 返回状态码&lt;/h4&gt;
&lt;p&gt;客户端发起请求，通过 API 访问服务端后，服务端应该给予操作的回馈，这次操作是失败了，还是成功了，请求中的参数是不是有什么错误。HTTP 返回码是一系列标准化的代码，在不同的场景下有不同的解释。服务端应该始终返回正确的状态码。&lt;br /&gt;
HTTP 返回码可以根据类型分组，下面是一些重要的类型:&lt;/p&gt;
&lt;h5&gt;2xx(成功类型)&lt;/h5&gt;
&lt;p&gt;这个类型下的返回码表示服务端成功接收到操作的请求，并且成功的执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;200 ok 这个返回码表示&lt;code class=&quot;language-text&quot;&gt;GET&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;PUT&lt;/code&gt;或&lt;code class=&quot;language-text&quot;&gt;POST&lt;/code&gt;请求成功执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;201 created 这个返回码表示数据的成功创建。比如，使用&lt;code class=&quot;language-text&quot;&gt;PUT&lt;/code&gt;方法请求创建新的新的数据成功后，应该返回 201。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;204 no countent 表示成功的处理了请求，但是没有任何返回数据。&lt;br /&gt;
一个比较好的例子就是:`DELETE /companies/43/employees/2 会删除这个员工的信息，但在返回的 body 中，我们并不需要任何数据，因为我们明确的告诉服务器我们要删除这条记录。如果操作有任何的错误，比如数据库中没有这个员工的数据的话，返回值就不会是 2xx 成功类型，而是 4xx 客户端错误类型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;3xx(重定向类型)&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;304 Not Modified 表示客户端本地已经有这次请求数据的缓存，服务端不需要再次传输同样的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;4xx(客户端错误类型)&lt;/h5&gt;
&lt;p&gt;这个类型的返回码表示客户端发起的起求有错误&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;400 Bad Request 表示服务端不清楚这次请求，所以没有处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;401 Unauthorized 表示客户端没有被授权访问这个 resource，应该带上授权凭证再次尝试请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;403 Forbidden 表示请求是正确的，但是用户无权访问这些 resource。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;404 Not Found 表示请求的 resouces，目前不可用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;410 Gone 表示请求的 resources 不再可用了，因为被有意的从服务端移除。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;5xx(服务端错误类型)&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;500 Internal Server Error 表示请求是正确的，但是在服务端处理时发生了错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;503 Server Unavailable 表示服务端不在线或无法接收处理请求。通常因为服务器在维护。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;5) 字段命名规则&lt;/h4&gt;
&lt;p&gt;你可以使用任何命名规则，但要注意整个应用内命名的一致性。如果请求的 body 或返回的 body 中使用的是 JSON 类型的数据，那么请使用&lt;code class=&quot;language-text&quot;&gt;camelCase(驼锋风格)&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;6) 搜索、排序、过滤和分页&lt;/h4&gt;
&lt;p&gt;这些都是对某数据集的查询，不会特意去创建新的 API 去进行这些查询。我们需要在使用&lt;code class=&quot;language-text&quot;&gt;GET&lt;/code&gt;请求方法的 API 的 URL 中拼接上查询的参数。&lt;br /&gt;
让我们看一些例子是如何实现这些操作的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对返回的结果&lt;strong&gt;排序&lt;/strong&gt;，如果需要对返回的公司信息进行排序，&lt;code class=&quot;language-text&quot;&gt;GET /companies&lt;/code&gt;这个端点应该能接收多个查询参数。比如: &lt;code class=&quot;language-text&quot;&gt;GET /companies?sort=rank_asc&lt;/code&gt;这个请求将返回的公司信息按排名的升序排列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对返回的结果&lt;strong&gt;过滤&lt;/strong&gt;，我可以在查询参数中传递不同的过滤选项。&lt;br /&gt;
比如这个请求: &lt;code class=&quot;language-text&quot;&gt;GET /companies?category=banking&amp;amp;location=india&lt;/code&gt; 会过滤出所有在印度的银行业的公司。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;搜索&lt;/strong&gt;，按名称搜索一个公司信息，这个 API 端点应该类似于 &lt;code class=&quot;language-text&quot;&gt;GET /companies?search=Digital Mackinsey&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据集过于庞大的时候需要&lt;strong&gt;分页&lt;/strong&gt;，把数据分成小块后返回，可以提升性能并且更容易去处理返回值。比如: &lt;code class=&quot;language-text&quot;&gt;GET /companies?page=23&lt;/code&gt;会返回所有公司信息的第 23 页。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 URL 中拼接了太多的查询参数，可能导致 URL 超过长度限制，服服端可能返回&lt;code class=&quot;language-text&quot;&gt;414 URI too long&lt;/code&gt;的错误状态代码。解决这个问题就不能用&lt;code class=&quot;language-text&quot;&gt;GET&lt;/code&gt;方法请求，需要使用&lt;code class=&quot;language-text&quot;&gt;POST&lt;/code&gt;，然后在请求 body 中传递参数。&lt;/p&gt;
&lt;h4&gt;7) 版本管理&lt;/h4&gt;
&lt;p&gt;如果你的 API 对外开放，升级其中的接口造成重大改变可能导致使用了你的 API 的服务或产品出现错误。
&lt;br/&gt;
&lt;code class=&quot;language-text&quot;&gt;http://api.yourservice.com/v1/companies/34/employees&lt;/code&gt; 就是一个设计良好的例子，在 API 的路径中包含了版本号。如果有重大改动的主要版本更新，我们可以在 API 中声明不同的版本号使用不同版本的 API，比如&lt;code class=&quot;language-text&quot;&gt;v2&lt;/code&gt;或&lt;code class=&quot;language-text&quot;&gt;v1.x.x&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;结束&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[JavaScript函数中的this指的到底是什么？]]></title><description><![CDATA[如果你不清楚如何判断 JS 函数中 this 的值是什么，也许你可以花些时间阅读一下这一篇博客。 在解释 值判断问题前，需要简单提一下另外一个同样重要，同样让 JS…]]></description><link>https://seanbruce.github.io/what-is-this/</link><guid isPermaLink="false">https://seanbruce.github.io/what-is-this/</guid><pubDate>Wed, 30 Jan 2019 08:51:19 GMT</pubDate><content:encoded>&lt;p&gt;
  &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/1bdf0dabe232dbd3430c3dae441680c9/a8a50/background.jpeg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
  
  &lt;span
    class=&quot;gatsby-resp-image-wrapper&quot;
    style=&quot;position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;&quot;
  &gt;
    &lt;span
      class=&quot;gatsby-resp-image-background-image&quot;
      style=&quot;padding-bottom: 66.640625%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHnVKphg//EABoQAQABBQAAAAAAAAAAAAAAAAIBABARIjH/2gAIAQEAAQUCHZVhOEtpr//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABgQAAIDAAAAAAAAAAAAAAAAAAAQAREh/9oACAEBAAY/AjYdr//EABsQAQACAgMAAAAAAAAAAAAAAAEAEBExIVGR/9oACAEBAAE/IQ6TBwondeREq91//9oADAMBAAIAAwAAABDw/wD/xAAVEQEBAAAAAAAAAAAAAAAAAAAQIf/aAAgBAwEBPxCn/8QAFREBAQAAAAAAAAAAAAAAAAAAECH/2gAIAQIBAT8Qh//EABsQAAIDAAMAAAAAAAAAAAAAAAERACExEIGh/9oACAEBAAE/ECCRlLYYqwUj7qEsteQjk2Q2EFtZ4//Z&apos;); background-size: cover; display: block;&quot;
    &gt;
      &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        style=&quot;width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;&quot;
        alt=&quot;programming&quot;
        title=&quot;&quot;
        src=&quot;/static/1bdf0dabe232dbd3430c3dae441680c9/f8fb9/background.jpeg&quot;
        srcset=&quot;/static/1bdf0dabe232dbd3430c3dae441680c9/e8976/background.jpeg 148w,
/static/1bdf0dabe232dbd3430c3dae441680c9/63df2/background.jpeg 295w,
/static/1bdf0dabe232dbd3430c3dae441680c9/f8fb9/background.jpeg 590w,
/static/1bdf0dabe232dbd3430c3dae441680c9/85e3d/background.jpeg 885w,
/static/1bdf0dabe232dbd3430c3dae441680c9/d1924/background.jpeg 1180w,
/static/1bdf0dabe232dbd3430c3dae441680c9/a8a50/background.jpeg 1280w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
      /&gt;
    &lt;/span&gt;
  &lt;/span&gt;
  
  &lt;/a&gt;
    &lt;/p&gt;
&lt;p&gt;如果你不清楚如何判断 JS 函数中 this 的值是什么，也许你可以花些时间阅读一下这一篇博客。&lt;/p&gt;
&lt;p&gt;在解释&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;值判断问题前，需要简单提一下另外一个同样重要，同样让 JS 新手困惑的知识点(&lt;strong&gt;闭包&lt;/strong&gt;)，因为对闭包的判断常常和对 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;值的判断弄混淆。&lt;/p&gt;
&lt;p&gt;闭包的判断和&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;判断最大的不同就是，&lt;strong&gt;闭包是在代码编写时就确定的，而 this 值的判定则是当函数调用的时候&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;才能确定，这一点非常重要&lt;/strong&gt;, 举个例子：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber NaN&quot; class=&quot;language-javascript line-numbers&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; names &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;jim&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Bob&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Amy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; funcs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;funcGenerator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;generatedFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;I&apos;m &quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; names&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  funcs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;funcGenerator&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;func &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; funcs&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 输出结果&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// I&apos;m jim&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// I&apos;m Bob&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// I&apos;m Amy&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第 9 行的循环里，&lt;code class=&quot;language-text&quot;&gt;funcGenerator&lt;/code&gt;被调用了三次，分别传入&lt;code class=&quot;language-text&quot;&gt;jim&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Bob&lt;/code&gt; &lt;code class=&quot;language-text&quot;&gt;Amy&lt;/code&gt;。返回的新函数存入&lt;code class=&quot;language-text&quot;&gt;funcs&lt;/code&gt;数组内。注意到到循环结束，生成的函数并没有被调用，而是被保存到了函数定义所处作用域&lt;em&gt;(funcGenerator 内部)&lt;/em&gt;的外面。当这三个函数在第 14 行被调用的时候，已经和&lt;code class=&quot;language-text&quot;&gt;funcGenerator&lt;/code&gt;内的&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;参数不在同一个作用域中，但是返回的每个函数内部的&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;引用，任然可以访问&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;参数的值，这就是闭包在发挥作用，目前，关于闭包你只需要记住上面黑体字的部分。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber NaN&quot; class=&quot;language-javascript line-numbers&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;tom&apos;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;jim&apos;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;ellen&apos;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; bar &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Bob&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;whoAmI&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; baz &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; bar&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;whoAmI

&lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
bar&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;whoAmI&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;baz&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 JavaSript 中函数的&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;值的判断遵循四条规则，它们之间有优先级的区别，最先被符合条件的规则决定了 this 的值，我按照优先级由低到高的顺序来介绍。&lt;/p&gt;
&lt;p&gt;上面代码中第 19 行输出的结果是多少？如果你回答是&lt;code class=&quot;language-text&quot;&gt;&amp;#39;ellen&amp;#39;&lt;/code&gt;，恭喜你答错了。假设 this 其实指向 function 自身，是常见的误解之一，第 14 行对&lt;code class=&quot;language-text&quot;&gt;foo&lt;/code&gt;的&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;属性的赋值并不会影响到 this 的值。&lt;/p&gt;
&lt;p&gt;如果你说：“答案是 &lt;code class=&quot;language-text&quot;&gt;jim&lt;/code&gt;，&lt;code class=&quot;language-text&quot;&gt;foo&lt;/code&gt; 函数内就定义了 &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt; 这个变量，然后最后返回这个值。“，恭喜你又错了，&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;的值也不是指向函数的作用域链&lt;em&gt;(尽管有时候，结果看似是一致的，后面会解释)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;正确的回答是&lt;code class=&quot;language-text&quot;&gt;tom&lt;/code&gt;，为什么？&lt;/p&gt;
&lt;h6&gt;第一条规则&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;当一个函数被直接的调用时，this 的值指向 window 这个对象，当使用”use strick”模式时，this 的值是 undefined。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里说的直接调用，指的就是&lt;code class=&quot;language-text&quot;&gt;foo()&lt;/code&gt;这种形式，第一行代码在全局作用域&lt;em&gt;window&lt;/em&gt;下定义了一个 name 的变量，即&lt;code class=&quot;language-text&quot;&gt;window.name = &amp;#39;tom&amp;#39;&lt;/code&gt;。this 指向的是&lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt;。&lt;em&gt;（这里如果用 ES6 中的 let 关键字声明变量的话，结果会不一样，我推荐你试试这种方法，并找出导致结果不一样的原因）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;现在可以解释，为什么输出的结果看起来像是对原型链的访问。有一种假设：如果第 4 行没有在&lt;code class=&quot;language-text&quot;&gt;foo&lt;/code&gt;内定义一个变量&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;，那么顺着作用域链去查找的话，就会在 window 这个全局作用域上找到&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;。 但事实是假设是错误的，结果的一致只是凑巧而已，&lt;strong&gt;&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;的值绝对不是函数的作用域链&lt;/strong&gt;。&lt;/p&gt;
&lt;h6&gt;第二条规则，比第一条优先：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;当一个函数以对象方法的形式被调用的时候，this 指向这个对象，可以使用 this.加上对象的属性名引用该对象的所有属性。
也可以说是 this 值的隐性绑定(implicit bind)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么你可以想到，因为上面的规则，第 20 行代码输出的结果是&lt;code class=&quot;language-text&quot;&gt;Bob&lt;/code&gt;。&lt;strong&gt;对象的方法&lt;/strong&gt;这种说法，来自于面向对象的编程思想。我更倾向不使用”对象的方法”这种说法，因为在 JavaScript 中，一个函数并不被一个对象所拥有，对象只是拥有一个函数的引用，一切都是对象的属性。由此引出一个陷阱。第 17 行代码，把&lt;strong&gt;对象的方法&lt;/strong&gt;保存到对象外一个变量中，结果输出是&lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt;中的&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;，而不是&lt;code class=&quot;language-text&quot;&gt;bar&lt;/code&gt;中的&lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;。正如前面所说的，对像只是拥有函数的引用，而不是函数本身。函数在何处定义同样不重要，无论是在对象内部被定义后被外部变量引用，还是将在别处被定义的函数的引用保存到对象的属性上，最终决定 this 的，还是函数的调用栈。&lt;code class=&quot;language-text&quot;&gt;object.function()&lt;/code&gt;只有这种形式的函数调用，this 才指向对象。&lt;/p&gt;
&lt;p&gt;上面的代码的最后三行的输出是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;tom&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Bob&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;tom&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h6&gt;第三条规则，比第二条优先：&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;从 ES5 开始每个函数的原型上多了两个方法，&lt;code class=&quot;language-text&quot;&gt;call&lt;/code&gt;和&lt;code class=&quot;language-text&quot;&gt;apply&lt;/code&gt;，两个方法的作用相同。 用法上，将需要绑定到 this 值的对象做为第一个参数传入(explicit bind)。对于 call 方法， 第一个参数后可以接任意个数的值，这些值会被传入被调用的函数做为参数。而 apply 的第二个参数则是接受一个数组，这个数组会做为参数传入被调用的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber NaN&quot; class=&quot;language-javascript line-numbers&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; bar &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Jobs&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bar&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//输出Jobs&lt;/span&gt;
foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bar&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//输出Jobs&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; baz &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Jim&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  whoAmI&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; foo&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

baz&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;whoAMI&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bar&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//输出jobs&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第 9，10 两行函数调用都使用了显式的 this 绑定。即使没有使用&lt;code class=&quot;language-text&quot;&gt;object.function()&lt;/code&gt;这种形式调用，函数的 this 值依然指向&lt;code class=&quot;language-text&quot;&gt;bar&lt;/code&gt;对象。第 17 行函数同时使用了对象的方法和 call 方法，因为 call 的优先级比较高，所以 this 的值是对象 bar，输出结果是&lt;code class=&quot;language-text&quot;&gt;jobs&lt;/code&gt;。如果多次函数调用需要绑定同样对象，函数后面加上 call 或 apply 这种写法略显繁琐，你可以用一个嵌套函数去返回一个用 apply 或 call 绑定过的函数调用，例如：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber NaN&quot; class=&quot;language-javascript line-numbers&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Jobs&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fooBinded&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;obj&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;fooBinded&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//输出 Jobs&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以自己写一个工具方法，抽象出函数包装的逻辑，避免代码了的重复并改善代码的可读性。但是更好的选择是使用函数原型上的 bind 方法。它的作用和函数包装 util 方法一样，但逻辑上更为谨慎，考虑到一些特殊情况下函数的表现。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber NaN&quot; class=&quot;language-javascript line-numbers&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; obj &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  name&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Jobs&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; fooAfterBind &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; foo&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;obj&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;fooAfterBind&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;//输出 Jobs&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;终于介绍到最后一个规则，是优先级最高的一个。&lt;/p&gt;
&lt;h6&gt;第四条规则&lt;/h6&gt;
&lt;blockquote&gt;
&lt;p&gt;函数调用时，前面加上 new 关键字，就是一次 new 调用。new 调用是 JavaScript 中用来模仿 OOP&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;中构造函数的调用的语法。new 调用时，会创建一个新的对象，函数内的 this 就指向这个新对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;javascript&quot;&gt;&lt;pre style=&quot;counter-reset: linenumber NaN&quot; class=&quot;language-javascript line-numbers&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; name
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; person &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Jobs&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

person&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name &lt;span class=&quot;token comment&quot;&gt;//输出 Jobs&lt;/span&gt;&lt;/code&gt;&lt;span aria-hidden=&quot;true&quot; class=&quot;line-numbers-rows&quot; style=&quot;white-space: normal; width: auto; left: 0;&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即使使用强绑定&lt;code class=&quot;language-text&quot;&gt;var BindedPerson = Person.bind({name: &amp;#39;sean&amp;#39;})&lt;/code&gt;，这时调用&lt;code class=&quot;language-text&quot;&gt;new BindedPerson(&amp;#39;Jobs&amp;#39;)&lt;/code&gt;返回的对象的 name 属性的值依然是 Jobs。这就是之前提到过 bind 处理的特殊情况。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;总结关于 this 值的知识点，判定函数内 this 值依赖四个规则，从优先级高到低分别是：new 函数调用、强绑定&lt;code class=&quot;language-text&quot;&gt;bind&lt;/code&gt;弱绑定&lt;code class=&quot;language-text&quot;&gt;apply``call&lt;/code&gt;、方法调用、普通函数调用。第一个符合条件的规则决定了 this 的值。理解 this 对理解 JavaScript 中的面向对象编程是必要的。可能在以后我会写一篇 Javascript 中的面向对象基础的博客。&lt;/p&gt;
&lt;p&gt;这篇博客就结束啦，see you next time!&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;函数的调用栈(function call stack)。&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;OOP(Object Oriented Programming) 面向对象编程。&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[简单的自我介绍]]></title><description><![CDATA[我是一个热爱 WEB 前端技术，同时也热爱分享的人。 以后我会不定时的在这里分享一切技术博客，主要针对的是 WEB 前端的知识，包括 WEB 前端开发中使用的基本技术，常用工具，以及一些个人的心得。可能以后还会加入 Node.js…]]></description><link>https://seanbruce.github.io/hello-world/</link><guid isPermaLink="false">https://seanbruce.github.io/hello-world/</guid><pubDate>Mon, 28 Jan 2019 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;我是一个热爱 WEB 前端技术，同时也热爱分享的人。&lt;/p&gt;
&lt;p&gt;以后我会不定时的在这里分享一切技术博客，主要针对的是 WEB 前端的知识，包括 WEB 前端开发中使用的基本技术，常用工具，以及一些个人的心得。可能以后还会加入 Node.js 的一切文章。&lt;/p&gt;
&lt;p&gt;希望我的博客内容能包含大家感兴趣的话题。&lt;/p&gt;</content:encoded></item></channel></rss>